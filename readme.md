# 1. pass
## Определение: pass — это оператор-заполнитель, который ничего не делает. 
## Он используется, когда необходимо указать синтаксически корректный блок кода, 
## который пока не нужно реализовывать.
    def функция_которая_пока_ничего_не_делает():
        pass


# 2. print
## Определение: print() — это встроенная функция Python, которая выводит переданные ей аргументы на консоль.
    print("Привет, мир!")


# 3. Комментарии
## Определение: Комментарии используются для пояснения кода и игнорируются интерпретатором Python. 
## Комментарии начинаются с символа #.
## Это однострочный комментарий


# 4. def
## Определение: def используется для объявления функции в Python. После def следует имя функции, 
## затем в круглых скобках — список параметров, и в конце — двоеточие.
    def моя_функция():
        print("Это функция")


# 5. pip install
## Определение: pip install — это команда для установки пакетов Python. 
## pip — это менеджер пакетов, который позволяет загружать и устанавливать библиотеки и модули.
    # Пример использования в консоли:
    # pip install requests


# 6. while
## Определение: while — это оператор цикла, который выполняет блок кода до тех пор, пока условие истинно.
    i = 0
    while i < 5:
        print(i)
        i += 1


# 7. append
## Определение: append() — это метод, который добавляет элемент в конец списка.
    список = [1, 2, 3]
    список.append(4)
    print(список)  # Вывод: [1, 2, 3, 4]


# 8. userSelection
## Определение: userSelection — это произвольное имя переменной, 
## которая обычно используется для хранения выбора пользователя.
    userSelection = input("Введите ваш выбор: ")
    print("Вы выбрали:", userSelection)


# 9. Main
## Определение: Main обычно используется для обозначения главной функции или точки входа в программу.
        def main():
            print("Это главная функция")

    if __name__ == "__main__":
        main()


# 10. import и import package
## Определение: import используется для подключения модулей и библиотек в программе.
    import math  # Импортируем встроенный модуль math
    import os  # Импортируем встроенный модуль os


# 11. os.system
## Определение: os.system — это функция модуля os, которая выполняет команду в оболочке (терминале/командной строке).
    os.system('cls' if os.name == 'nt' else 'clear')  # Очищает экран в зависимости от операционной системы


# 12. Сокращенный if
## Определение: Сокращенная форма if называется тернарным оператором, который позволяет записать условие и результат в одну строку.
    a = 10
    b = 20
    результат = "a больше" if a > b else "b больше"
    print(результат)

    true if condition else false
    'cls' if os.name == 'nt' else 'clear'


# 13. Путь к файлу (File path)
## Определение: File path — это строка, которая указывает путь к файлу или директории в файловой системе.
    путь = "/путь/к/файлу.txt"


# 14. Сохранение данных в JSON файл
## Определение: Для сохранения данных в формате JSON используется метод json.dump().
        import json


    file_path = "contacts.json"

    Ваш список контактов
    contacts = [
        {'user': 'sdfgs', 'email': 'agr'},
        {'user': 'sdfhsb', 'email': 'sdhs'},
        {'user': 'dfh', 'email': 'stfh'}
    ]

    Сохранение списка в файл
    with open('contacts.json', 'w') as file:
        json.dump(contacts, file, indent=4)  # indent=4 для красивого форматирования5

# 15. Загрузка из JSON файла
## Определение: Для загрузки данных из JSON файла используется метод json.load().
    import json

    Загрузка данных из файла JSON
    with open('contacts.json', 'r') as file:
        contacts = json.load(file)

    Теперь contacts содержит данные из файла
    print(contacts)
# 16. try / except
## Определение: try / except используется для обработки исключений.
    try:
        результат = 10 / 0
    except ZeroDivisionError:
        print("Ошибка: деление на ноль")



# 17. FizzBuzz
 ## Программа проходит числа от 1 до n (в данном случае, до 15).
## Если число делится на 3 и на 5, выводится "FizzBuzz".
## Если число делится только на 3, выводится "Fizz".
## Если число делится только на 5, выводится "Buzz".
## Если число не делится ни на 3, ни на 5, выводится само число.

## 1 способ
    def fizz_buzz(n):
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                print("FizzBuzz")
            elif i % 3 == 0:
                print("Fizz")
            elif i % 5 == 0:
                print("Buzz")
            else:
                print(i)

    # Пример использования:
    fizz_buzz(20)


## 2 способ
    def fizz_buzz(n):
        i = 1
        while i <= n:
            if i % 3 == 0 and i % 5 == 0:
                print("FizzBuzz")
            elif i % 3 == 0:
                print("Fizz")
            elif i % 5 == 0:
                print("Buzz")
            else:
                print(i)
            i += 1  # Увеличиваем значение i на 1 в каждом цикле

    # Пример использования:
    fizz_buzz(15)       


# 18. Debugger
## Если вы используете IDE, такую как PyCharm, Visual Studio Code, или другие, они обычно предоставляют более удобные инструменты для дебаггинга:

    Точки останова: Можно ставить кликом мыши в редакторе кода.
    Пошаговое выполнение: Графические кнопки для выполнения строки, перехода внутрь функции, или продолжения выполнения.
    Просмотр значений: Значения переменных показываются в отдельной панели, обновляясь в реальном времени.
    Как это полезно
    Дебаггинг помогает понять, почему код работает не так, как ожидалось. Вы можете проверить текущие значения переменных, увидеть, как изменяется состояние программы, и найти, где возникает ошибка.

    Использование дебаггера — это мощный способ глубже понять логику программы и быстро найти и исправить ошибки.

# 20. Глобальные и локальные переменные
## В Python переменные делятся на глобальные и локальные в зависимости от области их видимости (scope).

## Глобальные переменные
## Определение: Переменные, объявленные вне всех функций, являются глобальными и доступны из любой части программы, включая функции.
## Использование: Глобальные переменные можно использовать внутри функций, но если вы хотите изменить их значение, нужно явно указать, что переменная является глобальной, используя ключевое слово global.

    x = 10  # Глобальная переменная

    def modify_global():
        global x  # Указываем, что будем изменять глобальную переменную
        x = 20

    print(x)  # Выведет: 10
    modify_global()
    print(x)  # Выведет: 20 (значение переменной изменено в функции)
## Локальные переменные
## Определение: Переменные, объявленные внутри функции, являются локальными и доступны только в пределах этой функции.
## Использование: Локальные переменные используются для хранения данных, которые нужны только внутри конкретной функции. Вне функции они недоступны и не могут быть использованы.



    def example_function():
        y = 5  # Локальная переменная
        print(y)  # Работает, так как y доступна внутри функции

    example_function()
    print(y)  # Ошибка! Переменная y не доступна вне функции
    Пример совместного использования
    Рассмотрим пример, где используются и глобальные, и локальные переменные:


            x = 10  # Глобальная переменная

            def example_function():
                x = 5  # Локальная переменная (перекрывает глобальную внутри функции)
                print("Локальная переменная x:", x)

            example_function()  # Выведет: Локальная переменная x: 5
            print("Глобальная переменная x:", x)  # Выведет: Глобальная переменная x: 10
## В этом примере:

## Локальная переменная x в функции example_function существует только в пределах этой функции и не влияет на глобальную переменную x.
## После выполнения функции глобальная переменная x сохраняет своё первоначальное значение.
## Важные моменты: Глобальные переменные внутри функций: Если функция должна изменить значение глобальной переменной, нужно использовать global:

    count = 0

    def increment():
        global count
        count += 1

    increment()
    print(count)  # Выведет: 1
## Локальные переменные имеют приоритет: Если внутри функции создается переменная с тем же именем, что и глобальная, функция будет использовать локальную переменную.

## Избегайте избыточного использования глобальных переменных: Избыточное использование глобальных переменных может привести к трудности в отладке и сопровождении кода. Лучше использовать локальные переменные, если они нужны только в пределах функции.

## Заключение
## Глобальные переменные используются для хранения данных, которые должны быть доступны из разных частей программы, в то время как локальные переменные ограничиваются областью видимости функции, что делает код более структурированным и управляемым.


# 21. try/except
##  это ключевые компоненты обработки исключений в Python. Они позволяют перехватывать ошибки, которые возникают во время выполнения программы, и управлять ими, предотвращая неожиданное завершение программы.
## Основные элементы
    try блок: В этом блоке помещается код, который может вызвать исключение (ошибку). Если исключение происходит, выполнение программы передаётся в соответствующий блок except.

    except блок: В этом блоке находится код, который будет выполнен, если в блоке try произойдёт исключение. Можно указать, какой тип исключений перехватывать.

    else блок (опционально): Выполняется, если в блоке try не произошло никаких исключений.

    finally блок (опционально): Этот блок выполняется в любом случае, независимо от того, произошло исключение или нет. Он обычно используется для выполнения кода очистки, например, закрытия файлов или освобождения ресурсов.

## Пример 1: Базовое использование try/except
    try:
        x = int(input("Введите число: "))  # Преобразование строки в целое число
        print(f"Вы ввели число: {x}")
    except ValueError:
        print("Ошибка: Введено не число!")
## Как работает этот код:

## Если пользователь введёт число, оно будет успешно преобразовано в целое, и программа выведет его.
## Если пользователь введёт что-то, что не может быть преобразовано в число (например, текст), произойдёт исключение ValueError, и выполнение перейдёт в блок except, который выведет сообщение об ошибке.

## Пример 2: Обработка нескольких типов исключений
    try:
        a = int(input("Введите первое число: "))
        b = int(input("Введите второе число: "))
        result = a / b
        print(f"Результат деления: {result}")
    except ValueError:
        print("Ошибка: Введено не число!")
    except ZeroDivisionError:
        print("Ошибка: Деление на ноль невозможно!")

## Как работает этот код:

## ValueError перехватывает ошибку, если пользователь вводит не число.
## ZeroDivisionError перехватывает ошибку деления на ноль.

## Пример 3: Использование else и finally
    try:
        file = open("example.txt", "r")
        content = file.read()
    except FileNotFoundError:
        print("Ошибка: Файл не найден!")
    else:
        print("Файл был успешно прочитан.")
        print(content)
    finally:
        file.close()
        print("Файл закрыт.")

## Как работает этот код:

###  Если файл не найден, возникает исключение FileNotFoundError, и блок except выведет сообщение об ошибке.
### Если файл существует, блок else выведет содержимое файла.
### Блок finally закроет файл независимо от того, произошло исключение или нет.
### Зачем использовать try/except?
### Безопасность: Программа не прерывается внезапно из-за ошибки.
### Гибкость: Позволяет корректно реагировать на ошибки и принимать решения в зависимости от ситуации.
### Чистота кода: Обработка ошибок отделена от основной логики, что делает код более читаемым и управляемым.

## Пример 4: Общий except блок
## Вы можете использовать общий except блок для перехвата всех исключений, но это не всегда рекомендуется, так как может скрывать ошибки, которые важно видеть и исправлять:
    try:
        x = int(input("Введите число: "))
        result = 10 / x
    except Exception as e:  # Перехватывает любое исключение
        print(f"Произошла ошибка: {e}")
### Этот код выведет текст ошибки, если что-то пойдёт не так, но лучше явно указывать типы исключений, которые вы хотите перехватить.

## Заключение
## try/except — это мощный инструмент для обработки ошибок в Python, который позволяет сделать ваш код более надёжным и устойчивым к непредвиденным ситуациям. Выбор подходящей стратегии обработки исключений делает программу более управляемой и поддерживаемой.